<!DOCTYPE html>

<html lang="en">
<head>
  <meta name="generator" content="HTML Tidy for Linux (vers 25 March 2009), see www.w3.org">
  <meta charset="utf-8">
  <meta name="viewport" content="width=1024">
  <meta name="apple-mobile-web-app-capable" content="yes">

  <title>C++11 For A More Python-Like C++</title>
  <meta name="description" content="C++11 and shit">
  <meta name="author" content="Ami Tavory">
  <link href="css/html5.css" rel="stylesheet" type="text/css">
  <link href="css/shThemeDefault.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="css/css-tooltips.css" type="text/css">
  <link rel="stylesheet" href="css/carddeckslideshow.css" type="text/css">
  <style type="text/css">

  .stackcontainer{
  margin: 100px 0 10px 0;
  }

  #copy_if_stack{
  width: 850px; 
  height: 120px;
  }

  </style>
  <script src="http://code.jquery.com/jquery-1.9.1.js" type="text/javascript">
</script>
  <script src="http://code.jquery.com/ui/1.10.3/jquery-ui.js" type="text/javascript">
</script>
  <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js">
</script>
  <script src="js/carddeckslideshow.js" type="text/javascript">
</script>
  <script type="text/javascript">
var copy_if_stack = new carddeckslideshow({
  id: 'copy_if_stack',
    autoplay: false,
        cycles: 2,
            persist: false
            });
  </script>
  <script type="text/javascript">
$(document).ready(function(){
  document.addEventListener('impress:stepenter', function(event){
        if(event.target.id.search('outline') != -1)
  {
        $(".other").fadeTo("slow", 0.33);
        $(".sub_other").fadeTo("slow", 0.63);
  }
    }, false);
  document.addEventListener('impress:stepleave', function(event){
        $(".other").fadeTo("slow", 1);
        $(".sub_other").fadeTo("slow", 1);
    }, false);
  });
  </script>
</head>

<body class="impress-not-supported">
  <div class="fallback-message">
    <p>Your browser <b>doesn't support the features required</b> by impress.js, so you are presented with a simplified version of this presentation.</p>

    <p>For the best experience please use the latest <b>Chrome</b>, <b>Safari</b> or <b>Firefox</b> browser.</p>
  </div>

  <div id="impress">
    <div class="step slide" data-x="-980" data-y="1000" data-scale="0.01">
      <h1>C++11 For A More Python-Like C++</h1>
    </div>

    <div id="outline-intro" class="step slide" data-x="-1000" data-y="1000" data-scale="0.01">
      <h3>Outline</h3>

      <ul class="outline">
        <li class="current">Introduction</li>

        <li class="other">Core Language Improvements</li>

        <li class="other">Boost Helpers</li>

        <li class="other">Composition</li>

        <li class="other">Variadics</li>

        <li class="other">Concluding Mini-Example</li>
      </ul>
    </div>

    <div class="step slide" data-x="-1011" data-y="1011" data-scale="0.01"><img src="images/cpppython.png" width="80%"></div>

    <div class="step slide" data-x="-1000" data-y="1000">
      <h3>Working With Ranges In Python Is Fun</h3>

      <p>Very natural:</p>

      <ol>
        <li>Functional programming</li>

        <li>Lambda functions</li>

        <li>Range iteration</li>
      </ol>
    </div>

    <div class="step slide" data-x="-1000" data-y="1850">
      <h3>Python Functional Programming</h3>

      <ol>
        <li class="substep">Square root of non-negatives:

          <div class="smaller">
            <pre class='brush: python; gutter: false; toolbar: false'>
v = [1.1, 3, -2000, 5]
print [math.sqrt(e) for e in v if e &gt;= 0]
</pre>
          </div>
        </li>

        <li class="substep"># occurrences in sequence:

          <div class="smaller">
            <pre class='brush: python; gutter: false; toolbar: false'>
v = ['hello', 'hello', 'world']
print [(e, v.count(e)) for e in v]
</pre>
          </div>
        </li>

        <li class="substep">Chain

          <div class="smaller">
            <pre class='brush: python; gutter: false; toolbar: false'>
print [e for e in chain(v1, v2, v3)]
</pre>
          </div><object data="images/chain.svg" width="800" height="200" type="image/svg+xml">
            </object>
        </li>

        <li class="substep">Enumerate &amp; Filter

          <div class="smaller">
            <pre class='brush: python; gutter: false; toolbar: false'>
print [e for (i, e) in enumerate(v) if i % 2 == 0]
</pre>
          </div>
        </li>
      </ol>
    </div>

    <div class="step slide" data-x="-1000" data-y="2550">
      <h3>Python Lambda Functions</h3>

      <ol>
        <li class="substep">Sort according to absolute value:

          <div class="smaller">
            <pre class='brush: python; gutter: false; toolbar: false'>
v = [1.1, 3, -2000, 5]
sorted(v, key = lambda e: abs(e))
</pre>
          </div>
        </li>

        <li class="substep">Filter out short words:

          <div class="smaller">
            <pre class='brush: python; gutter: false; toolbar: false'>
v = ['hello', 'hello', 'world', 'a']
print filter(lambda e: len(e) &gt; 2, v)
</pre>
          </div>
        </li>
      </ol>
    </div>

    <div class="step slide" data-x="-2200" data-y="2400">
      <h3>Python Range Loops</h3>

      <div style="float: left; width: 50%;">
        <ol>
          <li class="substep">C &#8594; Python loop:

            <div class="smaller">
              <pre class='brush: python; gutter: false; toolbar: false'>
v = [1.1, 3, -2000, 5]
for i in range(len(v)):
    print v[i]
</pre>
            </div>
          </li>

          <li class="substep">More natural:

            <div class="smaller">
              <pre class='brush: python; gutter: false; toolbar: false'>
for e in v:
    print e
</pre>
            </div>
          </li>

          <li class="substep">and pythonic:

            <div class="smaller">
              <pre class='brush: python; gutter: false; toolbar: false'>
v1 = [1, 2, 3]
v2 = set([1, 2, 3])
for e in chain(v1, v2):
    print e
</pre>
            </div>
          </li>
        </ol>
      </div>

      <div style="float: right; width: 50%;">
        <ol start="3">
          <li class="substep">Enumerate stuff:

            <div class="smaller">
              <pre class='brush: python; gutter: false; toolbar: false'>
for i, e in enumerate(v):
    # Now at element #i = e
</pre>
            </div>
          </li>

          <li class="substep">Simplify loop body:

            <div class="smaller">
              <pre class='brush: python; gutter: false; toolbar: false'>
for e in v:
    if e % 2:
        ...
</pre>
            </div>&#8594;

            <div class="smaller">
              <pre class='brush: python; gutter: false; toolbar: false'>
for e in filter(v, lambda x: x % 2):
    ...
</pre>
            </div>
          </li>
        </ol>
      </div>
    </div>

    <div class="step" data-x="-2200" data-y="1700" data-rotate="180" data-scale="0.5">
      <h3>In (Old) C++</h3>

      <p>Print elements with words length &gt; 3</p>

      <ol>
        <li class="substep">Loop

          <ul>
            <li>Bad enough as is:
              <pre class='brush: cpp; gutter: false; toolbar: false'>
typedef 
    list&lt;string&gt;::const_iterator it_t;
for(it_t it = v.begin(); 
        it != v.end(); ++it)
    if(v.size() &gt; 3)
        cout &lt;&lt; v &lt;&lt; endl;
</pre>
            </li>

            <li class="substep">Enumeration? no problem
              <pre class='brush: cpp; gutter: false; toolbar: false'>
for(it_t it = v.begin(), size_t i = 0,
        it != v.end(); ++it)
    if(v.size() &gt; 3)
        cout &lt;&lt; i++ &lt;&lt; " " &lt;&lt; v &lt;&lt; endl;
</pre>
            </li>
          </ul>
        </li>
      </ol>
    </div>

    <div class="step slide" data-x="-2200" data-y="1180" data-rotate="180" data-scale="0.5">
      <ol start="2">
        <li>
          <code>&lt;algorithm&gt;</code>

          <ul>
            <li>Just use the appropriate functions &amp; classes:
              <pre class='brush: cpp; toolbar: false'>
copy_if(v.begin(), v.end(), 
    ostream_iterator&lt;size_t&gt;(cout),
    length_gt_3());
</pre>

              <div id="copy_if_stack" class="stackcontainer" onclick="javascript:copy_if_stack.navigate('next')" oncontextmenu=
              "javascript:copy_if_stack.navigate('prev'); return false;">
                <div class="inner">
                  <div>
                    <code>copy_if</code> copies from source-begin / source-end to target-begin anything that matches some predicate.
                  </div>
                </div>

                <div class="inner">
                  <div>
                    <code>ostream_iterator</code> is a stream to iterator adapter. Assigning to the iterator prints to the stream.
                  </div>
                </div>

                <div class="inner">
                  <div>
                    The predicate here is an instance of <code>length_gt_3</code>.
                  </div>
                </div>

                <div class="inner"></div>
              </div>
            </li>

            <li class="substep">Now just write the predicate
              <pre class='brush: cpp; gutter: false; toolbar: false'>
struct length_gt_3 : public unary_function&lt;
        const string &amp;, bool&gt;
{
    bool operator()(
        const string &amp;s) const;
};
</pre>
            </li>
          </ul>
        </li>
      </ol>
    </div>

    <div class="step" data-x="-2200" data-y="1700" data-rotate="180" data-scale="0.1" data-rotate-x="90"><img src="images/facepalm.jpg" width="80%"></div>

    <div class="step slide" data-x="0" data-y="-2600"><img src="images/morpheus.jpg" width="80%"></div>

    <div class="step slide" data-x="0" data-y="-1800">
      <h3>The C++11 Way</h3>

      <ol>
        <li>Chaining:

          <div class="smaller">
            <pre class='brush: cpp; toolbar: false'>
vector&lt;size_t&gt; v1{1, 2, 3}; 
set&lt;size_t&gt; v2{4, 5, 6, 7};
list&lt;size_t&gt; v3{6, 7, 8, 9};
for(auto e: chain(v1, v2, v3))
    cout &lt;&lt; e &lt;&lt; endl;
</pre>
          </div>
        </li>

        <li class="substep">Filtering:

          <div class="smaller">
            <pre class='brush: cpp; toolbar: false'>
vector&lt;size_t&gt; v{1, 2, 3}; 
for(auto &amp;e: filter([](size_t x){return !(x % 2);}, v)
    e /= 2;
</pre>
          </div>
        </li>

        <li class="substep">Enumeration:

          <div class="smaller">
            <pre class='brush: cpp; toolbar: false'>
vector&lt;string&gt; v{"hello", "my", "world"}; 
for(auto e: enumerate(v))
    cout &lt;&lt; e.index &lt;&lt; " " &lt;&lt; *e &lt;&lt; endl;
</pre>
          </div>
        </li>
      </ol>
    </div>

    <div class="step slide" data-x="0" data-y="-1050">
      <ol start="4">
        <li class="substep">Pipes:

          <div class="smaller">
            <pre class='brush: cpp; toolbar: false'>
vector&lt;size_t&gt; v{1, 2, 3, 4, 5, 6}; 
for(auto e: v | filter([](size_t x){return !(x % 2);} | enumerate()))
    cout &lt;&lt; e.index &lt;&lt; " " &lt;&lt; *e &lt;&lt; endl;
</pre>
          </div><object data="images/enumerate_filter.svg" width="800" height="200" type="image/svg+xml">
            </object>
        </li>

        <li class="substep">Products:

          <div class="smaller">
            <pre class='brush: cpp; toolbar: false'>
vector&lt;string&gt; assets{'asset0', 'asset1'};
list&lt;size_t&gt; tzs{0, 1, 3};
for(auto e: product(assets, tzs))
    cout &lt;&lt; get&lt;0&gt;(e) &lt;&lt; " " &lt;&lt; get&lt;1&gt;(e) &lt;&lt; endl;
</pre>
          </div>

          <div class="substep smaller">
            <pre class='brush: cpp; gutter: false; toolbar: false highlight: [1, 2, 3, 4, 5]'>
asset0 0
asset0 1
asset0 3
asset1 0
...
</pre>
          </div>
        </li>
      </ol>
    </div>

    <div id="outline-core" class="step slide" data-x="-500" data-y="630" data-rotate="90" data-scale="3">
      <h3>Outline</h3>

      <ul class="outline">
        <li class="other">Introduction</li>

        <li class="current">Core Language Improvements

          <ul>
            <li class="sub_other">Range Loops</li>

            <li class="sub_other"><code class="keyword">auto</code></li>

            <li class="sub_other">Lambda Functions</li>
          </ul>
        </li>

        <li class="other">Boost Helpers</li>

        <li class="other">Composition</li>

        <li class="other">Variadics</li>

        <li class="other">Concluding Mini-Example</li>
      </ul>
    </div>

    <div class="step slide" data-x="-2200" data-y="-600" data-rotate="90" data-scale="3">
      <h3>Range Loops</h3>

      <ol>
        <li>Iterate directly over a range:

          <div class="smaller">
            <pre class='brush: cpp; gutter: false; toolbar: false'>
vector&lt;size_t&gt; v{1, 2, 3, 7};
for(size_t e: v)
    cout &lt;&lt; e &lt;&lt; endl;
</pre>
          </div>
        </li>

        <li class="substep">Modification possible:

          <div class="smaller">
            <pre class='brush: cpp; gutter: false; toolbar: false'>
list&lt;size_t&gt; v{1, 2, 3, 7};
for(size_t &amp;e: v)
    ++e;
</pre>
          </div>
        </li>

        <li class="substep">What is a range?

          <ul>
            <li>Anything that supports <code>std::begin(v)</code> and std::end(v)</li>

            <li class="substep">That's right - they are now global functions</li>
          </ul>
        </li>
      </ol>
    </div>

    <div class="step slide" data-x="-2000" data-y="-800" data-rotate="90" data-scale="0.2">
      <h3><code class="keyword">auto</code></h3>

      <ol>
        <li>Some definitions still long

          <div class="smaller">
            <pre class='brush: cpp; gutter: false toolbar: false'>
unordered_map&lt;size_t, char&gt; v;
for(pair&lt;const size_t, char&gt; e: v)
    cout &lt;&lt; e.first &lt;&lt; " " &lt;&lt; e.second &lt;&lt; endl;
</pre>
          </div>
        </li>

        <li class="substep">Definition's type unambiguous &#8594; use <code class="keyword">auto</code>

          <div class="smaller">
            <pre class='brush: cpp; gutter: false toolbar: false'>
auto f = 0.8;
</pre>
          </div>

          <div class="substep smaller">
            <pre class='brush: cpp; gutter: false toolbar: false'>
unordered_map&lt;size_t, char&gt; v;
for(auto e: v)
    cout &lt;&lt; e.first &lt;&lt; " " &lt;&lt; e.second &lt;&lt; endl;
</pre>
          </div>
        </li>

        <li class="substep">
          <code class="keyword">auto</code> refers to type, not constness/reference

          <div class="smaller">
            <pre class='brush: cpp; gutter: false toolbar: false'>
auto f = 0.8;
const auto f1 = 0.8;
const auto &amp;f2 = 0.8;
auto *p = &amp;f;
</pre>
          </div>

          <div class="substep smaller">
            <pre class='brush: cpp; gutter: false toolbar: false'>
for(const auto &amp;e: v)
    cout &lt;&lt; e.first &lt;&lt; " " &lt;&lt; e.second &lt;&lt; endl;
</pre>
          </div>
        </li>
      </ol>
    </div>

    <div class="step slide" data-x="-2000" data-y="-1000" data-rotate="90" data-scale="0.05" data-z="200">
      <h3>Lambda Functions</h3>

      <ol>
        <li>Unnamed functions

          <div class="smaller">
            <pre class='brush: cpp; gutter: false; toolbar: false'>
cout &lt;&lt; [](double x){return fabs(sin(x));}(-3) &lt;&lt; endl;
</pre>
          </div>

          <div class="smaller substep">
            <pre class='brush: cpp; gutter: false; toolbar: false; highlight: [1]'>


0.14112
</pre>
          </div>
        </li>

        <li class="substep">Good for small, simple, non-reusable code:

          <ul>
            <li>Callbacks:

              <div class="smaller">
                <pre class='brush: cpp; gutter: false; toolbar: false'>
sort(v.begin(), v.end(), [](double x){return fabs(sin(x));});
</pre>
              </div>

              <div class="substep smaller">
                <pre class='brush: cpp; gutter: false; toolbar: false'>
for(auto e: filter([](double x){return fabs(sin(x));})
    ;
</pre>
              </div>
            </li>

            <li class="substep">Replacement to all bind libraries.

              <div class="smaller">
                <pre class='brush: cpp; gutter: false; toolbar: false'>
enum event{io_done, shutdown};                
void notify(event e);

asynch_io.call(op, [](){notify(io_done);});
</pre>
              </div>
            </li>
          </ul>
        </li>
      </ol>
    </div>

    <div class="step slide" data-x="-2025" data-y="-1000" data-rotate="90" data-scale="0.05" data-z="200">
      <ol start="3">
        <li class="substep">External variable use only with capture

          <div style="float: left; width: 50%;">
            <ul>
              <li>Won't work

                <div class="baddyshown smaller">
                  <pre class='brush: cpp; gutter: false; toolbar: false highlight: [3]'>
 int foo(const vector&lt;int&gt; &amp;v, int a) 
 {return *find_if(v.begin(), v.end(), 
    [](int x){return x &gt; a;});} 
</pre>
                </div>
              </li>

              <li class="substep">Capture all by value

                <div class="smaller" id="capture_0">
                  <pre class='brush: cpp; gutter: false; toolbar: false'>
[=](int x){return x &gt; a;}
</pre>
                </div>
              </li>
            </ul>
          </div>

          <div style="float: right; width: 50%;">
            <ul>
              <li class="substep">Capture all by reference

                <div class="smaller" id="capture_0">
                  <pre class='brush: cpp; gutter: false; toolbar: false'>
[&amp;](int x){return x &gt; *v.rbegin();}
</pre>
                </div>
              </li>

              <li class="substep">More variable-specific captures exist</li>
            </ul>
          </div>
        </li>
      </ol>
    </div>

    <div class="substep smaller">
      <pre class='brush: cpp; gutter: false; toolbar: false'>
sort(v.begin(), v.end(), [](double x){return fabs(sin(x));});
</pre>
    </div>

    <div class="step slide" data-x="-2060" data-y="-1100" data-rotate="90" data-scale="0.15" data-z="200">
      <h3>Checklist</h3>

      <ul class="check">
        <li class="check">Range Loops</li>

        <li class="check"><code class="keyword">auto</code></li>

        <li class="check">Lambda Functions</li>
      </ul>
    </div><script type="text/javascript">
$(".baddy").click(function() {
    $(this).addClass("baddyshown");
    });
    </script>

    <div id="outline-boost" class="step slide" data-x="2000" data-y="3000">
      <h3>Outline</h3>

      <ul class="outline">
        <li class="other">Introduction</li>

        <li class="other">Core Language Improvements</li>

        <li class="current">Boost Helpers

          <ul>
            <li class="sub_other"><code>boost::iterator_facade</code></li>

            <li class="sub_other"><code>boost::iterator_range</code></li>

            <li class="sub_other">Example: <code>chain</code></li>
          </ul>
        </li>

        <li class="other">Composition</li>

        <li class="other">Variadics</li>

        <li class="other">Concluding Mini-Example</li>
      </ul>
    </div>

    <div class="step slide" data-x="2000" data-y="3900" data-rotate-x="-20">
      <h3><code>boost::iterator_facade</code></h3>

      <ol>
        <li>Utility for creating new iterator types</li>

        <li class="substep">Example: iterator returning <code class="type">long</code>s in 2-increments

          <div class="smaller">
            <pre class='brush: cpp gutter: false toolbar: false'>
    class inc_2_it
    {
        ...
    };

    for(inc_2_it it(0); it != inc_2_it(10); ++it)
        cout &lt;&lt; *it &lt;&lt; " ";
    
</pre>
            <pre class="brush: cpp gutter: false toolbar: false highlight: [1]">
    0 2 4 6 8
    
</pre>
          </div>
        </li>
      </ol>
    </div>

    <div class="step slide" data-x="3000" data-y="3900" data-rotate-x="-20">
      <div class="substep inc_2_it smaller" id="inc_2_it_1">
        <pre class='brush: cpp toolbar: false'>
    class inc_2_it : 
        public boost::iterator_facade&lt;
            inc_2_it,
            const long,
            boost::random_access_traversal_tag&gt;
    {
    private:
        long m_i;

        friend class boost::iterator_core_access;

    public:
        explicit inc_2_it(long i) : m_i(i){}

        void increment(){m_i += 2;}

        const long &amp;reference() const{return m_i;}

        bool equal_to(const inc_2_it &amp;o) const
        {return m_i == other.m_i;}
    };
    
</pre>
      </div>

      <div class="inc_2_it smaller" id="inc_2_it_2" style="display: none;" data-tip=
      "Subclass iterator_facade; instantiate: subclass, value_type, and iterator type">
        <pre class='brush: cpp toolbar: false highlight: [2, 3, 4, 5]'>
    class inc_2_it : 
        public boost::iterator_facade&lt;
            inc_2_it,
            const long,
            boost::random_access_traversal_tag&gt;
    {
    private:
        long m_i;

        friend class boost::iterator_core_access;

    public:
        explicit inc_2_it(long i) : m_i(i){}

        void increment(){m_i += 2;}

        const long &amp;reference() const{return m_i;}

        bool equal_to(const inc_2_it &amp;o) const
        {return m_i == other.m_i;}
    };
    
</pre>
      </div>

      <div class="inc_2_it smaller" id="inc_2_it_3" style="display: none;" data-tip="Current index">
        <pre class='brush: cpp toolbar: false highlight: [8]'>
    class inc_2_it : 
        public boost::iterator_facade&lt;
            inc_2_it,
            const long,
            boost::random_access_traversal_tag&gt;
    {
    private:
        long m_i;

        friend class boost::iterator_core_access;

    public:
        explicit inc_2_it(long i) : m_i(i){}

        void increment(){m_i += 2;}

        const long &amp;reference() const{return m_i;}

        bool equal_to(const inc_2_it &amp;o) const
        {return m_i == other.m_i;}
    };
    
</pre>
      </div>

      <div class="inc_2_it smaller" id="inc_2_it_4" style="display: none;" data-tip="Give boost access to internals">
        <pre class='brush: cpp toolbar: false highlight: [10]'>
    class inc_2_it : 
        public boost::iterator_facade&lt;
            inc_2_it,
            const long,
            boost::random_access_traversal_tag&gt;
    {
    private:
        long m_i;

        friend class boost::iterator_core_access;

    public:
        explicit inc_2_it(long i) : m_i(i){}

        void increment(){m_i += 2;}

        const long &amp;reference() const{return m_i;}

        bool equal_to(const inc_2_it &amp;o) const
        {return m_i == other.m_i;}
    };
    
</pre>
      </div>

      <div class="inc_2_it smaller" id="inc_2_it_5" style="display: none;" data-tip="Ctor; initialize index">
        <pre class='brush: cpp toolbar: false highlight: [13]'>
    class inc_2_it : 
        public boost::iterator_facade&lt;
            inc_2_it,
            const long,
            boost::random_access_traversal_tag&gt;
    {
    private:
        long m_i;

        friend class boost::iterator_core_access;

    public:
        explicit inc_2_it(long i) : m_i(i){}

        void increment(){m_i += 2;}

        const long &amp;reference() const{return m_i;}

        bool equal_to(const inc_2_it &amp;o) const
        {return m_i == other.m_i;}
    };
    
</pre>
      </div>

      <div class="inc_2_it smaller" id="inc_2_it_6" style="display: none;" data-tip="inc; add 2">
        <pre class='brush: cpp toolbar: false highlight: [15]'>
    class inc_2_it : 
        public boost::iterator_facade&lt;
            inc_2_it,
            const long,
            boost::random_access_traversal_tag&gt;
    {
    private:
        long m_i;

        friend class boost::iterator_core_access;

    public:
        explicit inc_2_it(long i) : m_i(i){}

        void increment(){m_i += 2;}

        const long &amp;reference() const{return m_i;}

        bool equal_to(const inc_2_it &amp;o) const
        {return m_i == other.m_i;}
    };
    
</pre>
      </div>

      <div class="inc_2_it smaller" id="inc_2_it_7" style="display: none;" data-tip="deref; return index">
        <pre class='brush: cpp toolbar: false highlight: [17]'>
    class inc_2_it : 
        public boost::iterator_facade&lt;
            inc_2_it,
            const long,
            boost::random_access_traversal_tag&gt;
    {
    private:
        long m_i;

        friend class boost::iterator_core_access;

    public:
        explicit inc_2_it(long i) : m_i(i){}

        void increment(){m_i += 2;}

        const long &amp;reference() const{return m_i;}

        bool equal_to(const inc_2_it &amp;o) const
        {return m_i == other.m_i;}
    };
    
</pre>
      </div>

      <div class="inc_2_it smaller" id="inc_2_it_8" style="display: none;" data-tip="equal to other iff indices equal">
        <pre class='brush: cpp toolbar: false highlight: [19, 20]'>
    class inc_2_it : 
        public boost::iterator_facade&lt;
            inc_2_it,
            const long,
            boost::random_access_traversal_tag&gt;
    {
    private:
        long m_i;

        friend class boost::iterator_core_access;

    public:
        explicit inc_2_it(long i) : m_i(i){}

        void increment(){m_i += 2;}

        const long &amp;reference() const{return m_i;}

        bool equal_to(const inc_2_it &amp;o) const
        {return m_i == other.m_i;}
    };
    
</pre>
      </div><script type="text/javascript">
$('#inc_2_it_1').click(function(e){    
        $('#inc_2_it_1').hide()
        $('#inc_2_it_2').show()
        });
        $('#inc_2_it_2').contextmenu(function(e){    
        $('#inc_2_it_1').show()
        $('#inc_2_it_2').hide()
        return false;
        });
        $('#inc_2_it_2').click(function(e){    
        $('#inc_2_it_2').hide()
        $('#inc_2_it_3').show()
        });
        $('#inc_2_it_3').contextmenu(function(e){    
        $('#inc_2_it_2').show()
        $('#inc_2_it_3').hide()
        return false;
        });
        $('#inc_2_it_3').click(function(e){    
        $('#inc_2_it_3').hide()
        $('#inc_2_it_4').show()
        });
        $('#inc_2_it_4').contextmenu(function(e){    
        $('#inc_2_it_3').show()
        $('#inc_2_it_4').hide()
        return false;
        });
        $('#inc_2_it_4').click(function(e){    
        $('#inc_2_it_4').hide()
        $('#inc_2_it_5').show()
        });
        $('#inc_2_it_5').contextmenu(function(e){    
        $('#inc_2_it_4').show()
        $('#inc_2_it_5').hide()
        return false;
        });
        $('#inc_2_it_5').click(function(e){    
        $('#inc_2_it_5').hide()
        $('#inc_2_it_6').show()
        });
        $('#inc_2_it_6').contextmenu(function(e){    
        $('#inc_2_it_5').show()
        $('#inc_2_it_6').hide()
        return false;
        });
        $('#inc_2_it_6').click(function(e){    
        $('#inc_2_it_6').hide()
        $('#inc_2_it_7').show()
        });
        $('#inc_2_it_7').contextmenu(function(e){    
        $('#inc_2_it_6').show()
        $('#inc_2_it_7').hide()
        return false;
        });
        $('#inc_2_it_7').click(function(e){    
        $('#inc_2_it_7').hide()
        $('#inc_2_it_8').show()
        });
        $('#inc_2_it_8').contextmenu(function(e){    
        $('#inc_2_it_7').show()
        $('#inc_2_it_8').hide()
        return false;
        });
      </script>
    </div>

    <div class="step slide" data-x="3000" data-y="5300" data-rotate-x="-50" data-rotate='50'>
      <h3><code>boost::iterator_range</code></h3>

      <ol>
        <li>Utility for creating new ranges from iterators</li>

        <li class="substep">Example

          <div class="inc_2_it_range smaller" id="inc_2_it_range_0">
            <pre class='brush: cpp toolbar: false'>
    boost::iterator_range&lt;inc_2_it&gt;
        inc_2_range(long b, long e)
    {
        return boost::make_iterator_range(
            inc_2_it(b),
            inc_2_it(e + (b - e) % 2));
    }
    
</pre>
          </div>

          <div class="inc_2_it_range smaller" id="inc_2_it_range_1" style="display: none;" data-tip="range-iterator specialized to iterator type">
            <pre class='brush: cpp toolbar: false highlight: [1]'>
    boost::iterator_range&lt;inc_2_it&gt;
        inc_2_range(long b, long e)
    {
        return boost::make_iterator_range(
            inc_2_it(b),
            inc_2_it(e + (b - e) % 2));
    }
    
</pre>
          </div>

          <div class="inc_2_it_range smaller" id="inc_2_it_range_2" style="display: none;" data-tip="begin and end indices">
            <pre class='brush: cpp toolbar: false highlight: [2]'>
    boost::iterator_range&lt;inc_2_it&gt;
        inc_2_range(long b, long e)
    {
        return boost::make_iterator_range(
            inc_2_it(b),
            inc_2_it(e + (b - e) % 2));
    }
    
</pre>
          </div>

          <div class="inc_2_it_range smaller" id="inc_2_it_range_3" style="display: none;" data-tip="iterator-range from both iterators">
            <pre class='brush: cpp toolbar: false highlight: [4, 5, 6]'>
    boost::iterator_range&lt;inc_2_it&gt;
        inc_2_range(long b, long e)
    {
        return boost::make_iterator_range(
            inc_2_it(b),
            inc_2_it(e + (b - e) % 2));
    }
    
</pre>
          </div>

          <div class="substep smaller">
            <pre class='brush: cpp gutter: false toolbar: false'>
    for(auto e: inc_2_range(0, 10))
        cout &lt;&lt; *it &lt;&lt; " ";
    
</pre>
            <pre class="brush: cpp gutter: false toolbar: false highlight: [1]">
    0 2 4 6 8
    
</pre>
          </div>
        </li>
      </ol><script type="text/javascript">
$('#inc_2_it_range_0').click(function(e){    
        $('#inc_2_it_range_0').hide()
        $('#inc_2_it_range_1').show()
        });
        $('#inc_2_it_range_1').contextmenu(function(e){    
        $('#inc_2_it_range_0').show()
        $('#inc_2_it_range_1').hide()
        return false;
        });
        $('#inc_2_it_range_1').click(function(e){    
        $('#inc_2_it_range_1').hide()
        $('#inc_2_it_range_2').show()
        });
        $('#inc_2_it_range_2').contextmenu(function(e){    
        $('#inc_2_it_range_1').show()
        $('#inc_2_it_range_2').hide()
        return false;
        });
        $('#inc_2_it_range_2').click(function(e){    
        $('#inc_2_it_range_2').hide()
        $('#inc_2_it_range_3').show()
        });
        $('#inc_2_it_range_3').contextmenu(function(e){    
        $('#inc_2_it_range_2').show()
        $('#inc_2_it_range_3').hide()
        return false;
        });
      </script>
    </div>

    <div class="step slide" data-x="3500" data-y="4600" data-scale="1" data-z="-1000">
      <h3>Example: Simplified <code>chain</code></h3>

      <div class="smaller">
        <pre class='brush: cpp; gutter: false; toolbar: false'>
    vector&lt;size_t&gt; v1{1, 2, 3}; list&lt;size_t&gt; v3{6, 7, 8, 9};
    for(auto e: chain(v1, v2, v3)) cout &lt;&lt; e &lt;&lt; endl;
</pre>
      </div>

      <ol>
        <li class="substep">Chaining iterator <object data="images/chain_2.svg" width="800" height="400" type="image/svg+xml">
          </object></li>

        <li class="substep">Range interface</li>
      </ol>
    </div>

    <div class="step slide" data-x="4500" data-y="4600" data-scale="1" data-z="-1000">
      <div class="chain_2 smaller" id="chain_2_0">
        <pre class='brush: cpp toolbar: false'>
template&lt;typename It0, typename It1&gt;
class chain_it : public boost::iterator_facade&lt;
    chain_it&lt;It0, It1&gt;,
    typename std::iterator_traits&lt;It0&gt;::value_type,
    boost::forward_traversal_tag&gt;
{
private:
    It0 m_b0, m_e0; It1 m_b1, m_e1;

    friend class boost::iterator_core_access;

public:
    explicit chain_it(It1 b1, It1 e1, It1 b1, It1 e1) : 
        m_b0(b0), m_e0(e0), m_b1(b1), m_e1(e1){}

    void increment(){if(m_b0 == m_e0)++m_b1; else ++m_b_0;}

    const typename std::iterator_traits&lt;It0&gt;::reference 
    reference() const 
    {m_b_0 == m_e_0? *m_b_1: *m_b_0;}

    bool equal_to(const chain_it&lt;It0, It1&gt; &amp;o) const
    {return m_b0 == o.m_b0 &amp;&amp; m_b1 == o.m_b1);
};
</pre>
      </div>

      <div class="chain_2 smaller" id="chain_2_1" style="display:none" data-tip="Boilerplate template code">
        <pre class='brush: cpp toolbar: false highlight: [1, 2, 3, 4, 5]'>
template&lt;typename It0, typename It1&gt;
class chain_it : public boost::iterator_facade&lt;
    chain_it&lt;It0, It1&gt;,
    typename std::iterator_traits&lt;It0&gt;::value_type,
    boost::forward_traversal_tag&gt;
{
private:
    It0 m_b0, m_e0; It1 m_b1, m_e1;

    friend class boost::iterator_core_access;

public:
    explicit chain_it(It1 b1, It1 e1, It1 b1, It1 e1) : 
        m_b0(b0), m_e0(e0), m_b1(b1), m_e1(e1){}

    void increment(){if(m_b0 == m_e0)++m_b1; else ++m_b_0;}

    const typename std::iterator_traits&lt;It0&gt;::reference 
    reference() const 
    {m_b_0 == m_e_0? *m_b_1: *m_b_0;}

    bool equal_to(const chain_it&lt;It0, It1&gt; &amp;o) const
    {return m_b0 == o.m_b0 &amp;&amp; m_b1 == o.m_b1);
};
</pre>
      </div>

      <div class="chain_2 smaller" id="chain_2_2" style="display:none" data-tip="Iterators for 1st, 2nd ranges">
        <pre class='brush: cpp toolbar: false highlight: [8]'>
template&lt;typename It0, typename It1&gt;
class chain_it : public boost::iterator_facade&lt;
    chain_it&lt;It0, It1&gt;,
    typename std::iterator_traits&lt;It0&gt;::value_type,
    boost::forward_traversal_tag&gt;
{
private:
    It0 m_b0, m_e0; It1 m_b1, m_e1;

    friend class boost::iterator_core_access;

public:
    explicit chain_it(It1 b1, It1 e1, It1 b1, It1 e1) : 
        m_b0(b0), m_e0(e0), m_b1(b1), m_e1(e1){}

    void increment(){if(m_b0 == m_e0)++m_b1; else ++m_b_0;}

    const typename std::iterator_traits&lt;It0&gt;::reference 
    reference() const 
    {m_b_0 == m_e_0? *m_b_1: *m_b_0;}

    bool equal_to(const chain_it&lt;It0, It1&gt; &amp;o) const
    {return m_b0 == o.m_b0 &amp;&amp; m_b1 == o.m_b1);
};
</pre>
      </div>

      <div class="chain_2 smaller" id="chain_2_3" style="display:none" data-tip="Ctor; init 1st, 2nd iterators">
        <pre class='brush: cpp toolbar: false highlight: [13, 14]'>
template&lt;typename It0, typename It1&gt;
class chain_it : public boost::iterator_facade&lt;
    chain_it&lt;It0, It1&gt;,
    typename std::iterator_traits&lt;It0&gt;::value_type,
    boost::forward_traversal_tag&gt;
{
private:
    It0 m_b0, m_e0; It1 m_b1, m_e1;

    friend class boost::iterator_core_access;

public:
    explicit chain_it(It1 b1, It1 e1, It1 b1, It1 e1) : 
        m_b0(b0), m_e0(e0), m_b1(b1), m_e1(e1){}

    void increment(){if(m_b0 == m_e0)++m_b1; else ++m_b_0;}

    const typename std::iterator_traits&lt;It0&gt;::reference 
    reference() const 
    {m_b_0 == m_e_0? *m_b_1: *m_b_0;}

    bool equal_to(const chain_it&lt;It0, It1&gt; &amp;o) const
    {return m_b0 == o.m_b0 &amp;&amp; m_b1 == o.m_b1);
};
</pre>
      </div>

      <div class="chain_2 smaller" id="chain_2_4" style="display:none" data-tip="If in 2nd range, inc it; otherwise, inc 1st">
        <pre class='brush: cpp toolbar: false highlight: [16]'>
template&lt;typename It0, typename It1&gt;
class chain_it : public boost::iterator_facade&lt;
    chain_it&lt;It0, It1&gt;,
    typename std::iterator_traits&lt;It0&gt;::value_type,
    boost::forward_traversal_tag&gt;
{
private:
    It0 m_b0, m_e0; It1 m_b1, m_e1;

    friend class boost::iterator_core_access;

public:
    explicit chain_it(It1 b1, It1 e1, It1 b1, It1 e1) : 
        m_b0(b0), m_e0(e0), m_b1(b1), m_e1(e1){}

    void increment(){if(m_b0 == m_e0)++m_b1; else ++m_b_0;}

    const typename std::iterator_traits&lt;It0&gt;::reference 
    reference() const 
    {m_b_0 == m_e_0? *m_b_1: *m_b_0;}

    bool equal_to(const chain_it&lt;It0, It1&gt; &amp;o) const
    {return m_b0 == o.m_b0 &amp;&amp; m_b1 == o.m_b1);
};
</pre>
      </div>

      <div class="chain_2 smaller" id="chain_2_5" style="display:none" data-tip="If in 2nd range, return value from it; otherwise from first">
        <pre class='brush: cpp toolbar: false highlight: [18, 19, 20]'>
template&lt;typename It0, typename It1&gt;
class chain_it : public boost::iterator_facade&lt;
    chain_it&lt;It0, It1&gt;,
    typename std::iterator_traits&lt;It0&gt;::value_type,
    boost::forward_traversal_tag&gt;
{
private:
    It0 m_b0, m_e0; It1 m_b1, m_e1;

    friend class boost::iterator_core_access;

public:
    explicit chain_it(It1 b1, It1 e1, It1 b1, It1 e1) : 
        m_b0(b0), m_e0(e0), m_b1(b1), m_e1(e1){}

    void increment(){if(m_b0 == m_e0)++m_b1; else ++m_b_0;}

    const typename std::iterator_traits&lt;It0&gt;::reference 
    reference() const 
    {m_b_0 == m_e_0? *m_b_1: *m_b_0;}

    bool equal_to(const chain_it&lt;It0, It1&gt; &amp;o) const
    {return m_b0 == o.m_b0 &amp;&amp; m_b1 == o.m_b1);
};
</pre>
      </div>

      <div class="chain_2 smaller" id="chain_2_6" style="display:none" data-tip="Equal iff begin its are equal">
        <pre class='brush: cpp toolbar: false highlight: [22, 23]'>
template&lt;typename It0, typename It1&gt;
class chain_it : public boost::iterator_facade&lt;
    chain_it&lt;It0, It1&gt;,
    typename std::iterator_traits&lt;It0&gt;::value_type,
    boost::forward_traversal_tag&gt;
{
private:
    It0 m_b0, m_e0; It1 m_b1, m_e1;

    friend class boost::iterator_core_access;

public:
    explicit chain_it(It1 b1, It1 e1, It1 b1, It1 e1) : 
        m_b0(b0), m_e0(e0), m_b1(b1), m_e1(e1){}

    void increment(){if(m_b0 == m_e0)++m_b1; else ++m_b_0;}

    const typename std::iterator_traits&lt;It0&gt;::reference 
    reference() const 
    {m_b_0 == m_e_0? *m_b_1: *m_b_0;}

    bool equal_to(const chain_it&lt;It0, It1&gt; &amp;o) const
    {return m_b0 == o.m_b0 &amp;&amp; m_b1 == o.m_b1);
};
</pre>
      </div><script type="text/javascript">
$('#chain_2_0').click(function(e){    
      $('#chain_2_0').hide()
      $('#chain_2_1').show()
      });
      $('#chain_2_1').contextmenu(function(e){    
      $('#chain_2_0').show()
      $('#chain_2_1').hide()
      return false;
      });
      $('#chain_2_2').click(function(e){    
      $('#chain_2_2').hide()
      $('#chain_2_3').show()
      });
      $('#chain_2_1').click(function(e){    
      $('#chain_2_1').hide()
      $('#chain_2_2').show()
      });
      $('#chain_2_2').contextmenu(function(e){    
      $('#chain_2_1').show()
      $('#chain_2_2').hide()
      return false;
      });
      $('#chain_2_2').click(function(e){    
      $('#chain_2_2').hide()
      $('#chain_2_3').show()
      });
      $('#chain_2_3').contextmenu(function(e){    
      $('#chain_2_2').show()
      $('#chain_2_3').hide()
      return false;
      });
      $('#chain_2_3').click(function(e){    
      $('#chain_2_3').hide()
      $('#chain_2_4').show()
      });
      $('#chain_2_4').contextmenu(function(e){    
      $('#chain_2_3').show()
      $('#chain_2_4').hide()
      return false;
      });
      $('#chain_2_4').click(function(e){    
      $('#chain_2_4').hide()
      $('#chain_2_5').show()
      });
      $('#chain_2_5').contextmenu(function(e){    
      $('#chain_2_4').show()
      $('#chain_2_5').hide()
      return false;
      });
      $('#chain_2_5').click(function(e){    
      $('#chain_2_5').hide()
      $('#chain_2_6').show()
      });
      $('#chain_2_6').contextmenu(function(e){    
      $('#chain_2_5').show()
      $('#chain_2_6').hide()
      return false;
      });
      </script>
    </div>

    <div class="step slide" data-x="5500" data-y="4600" data-scale="1" data-z="-1000">
      <div class="chain_2n smaller" id="chain_2n_0">
        <pre class='brush: cpp toolbar: false'>
template&lt;class Range0, class Range1&gt;
boost::iterator_range&lt;
    chain_it&lt;
        typename Range0::const_iterator, 
        typename Range1::const_iterator&gt;&gt;
chain(const Range0 &amp;r0, const Range1 &amp;r1)
{
    auto b0 = std::begin(r0), e0 = std::end(r1);
    auto b1 = std::begin(r1), e1 = std::end(r1);
    return boost::make_iterator_range(
        chain_it(b0, e0, b1, e1),
        chain_it(e0, e0, e1, e1));
}
</pre>
      </div>

      <div class="chain_2n smaller" id="chain_2n_1" style="display:none" data-tip="Function takes two ranges">
        <pre class='brush: cpp toolbar: false highlight: [6]'>
template&lt;class Range0, class Range1&gt;
boost::iterator_facade&lt;
    chain_it&lt;
        typename Range0::const_iterator, 
        typename Range1::const_iterator&gt;&gt;
chain(const Range0 &amp;r0, const Range1 &amp;r1)
{
    auto b0 = std::begin(r0), e0 = std::end(r1);
    auto b1 = std::begin(r1), e1 = std::end(r1);
    return boost::make_chain_iterator(
        chain_it(b0, e0, b1, e1),
        chain_it(e0, e0, e1, e1));
}
</pre>
      </div>

      <div class="chain_2n smaller" id="chain_2n_2" style="display:none" data-tip="Return value; usual template stuff">
        <pre class='brush: cpp toolbar: false highlight: [1, 2, 3, 4, 5]'>
template&lt;class Range0, class Range1&gt;
boost::iterator_facade&lt;
    chain_it&lt;
        typename Range0::const_iterator, 
        typename Range1::const_iterator&gt;&gt;
chain(const Range0 &amp;r0, const Range1 &amp;r1)
{
    auto b0 = std::begin(r0), e0 = std::end(r1);
    auto b1 = std::begin(r1), e1 = std::end(r1);
    return boost::make_chain_iterator(
        chain_it(b0, e0, b1, e1),
        chain_it(e0, e0, e1, e1));
}
</pre>
      </div>

      <div class="chain_2n smaller" id="chain_2n_3" style="display:none" data-tip="All begin and end iterators">
        <pre class='brush: cpp toolbar: false highlight: [8, 9]'>
template&lt;class Range0, class Range1&gt;
boost::iterator_facade&lt;
    chain_it&lt;
        typename Range0::const_iterator, 
        typename Range1::const_iterator&gt;&gt;
chain(const Range0 &amp;r0, const Range1 &amp;r1)
{
    auto b0 = std::begin(r0), e0 = std::end(r1);
    auto b1 = std::begin(r1), e1 = std::end(r1);
    return boost::make_chain_iterator(
        chain_it(b0, e0, b1, e1),
        chain_it(e0, e0, e1, e1));
}
</pre>
      </div>

      <div class="chain_2n smaller" id="chain_2n_4" style="display:none" data-tip="Return a range itertor">
        <pre class='brush: cpp toolbar: false highlight: [10, 11, 12]'>
template&lt;class Range0, class Range1&gt;
boost::iterator_facade&lt;
    chain_it&lt;
        typename Range0::const_iterator, 
        typename Range1::const_iterator&gt;&gt;
chain(const Range0 &amp;r0, const Range1 &amp;r1)
{
    auto b0 = std::begin(r0), e0 = std::end(r1);
    auto b1 = std::begin(r1), e1 = std::end(r1);
    return boost::make_chain_iterator(
        chain_it(b0, e0, b1, e1),
        chain_it(e0, e0, e1, e1));
}
</pre>
      </div><script type="text/javascript">
$('#chain_2n_0').click(function(e){    
      $('#chain_2n_0').hide()
      $('#chain_2n_1').show()
      });
      $('#chain_2n_1').contextmenu(function(e){    
      $('#chain_2n_0').show()
      $('#chain_2n_1').hide()
      return false;
      });
      $('#chain_2n_2').click(function(e){    
      $('#chain_2n_2').hide()
      $('#chain_2n_3').show()
      });
      $('#chain_2n_1').click(function(e){    
      $('#chain_2n_1').hide()
      $('#chain_2n_2').show()
      });
      $('#chain_2n_2').contextmenu(function(e){    
      $('#chain_2n_1').show()
      $('#chain_2n_2').hide()
      return false;
      });
      $('#chain_2n_2').click(function(e){    
      $('#chain_2n_2').hide()
      $('#chain_2n_3').show()
      });
      $('#chain_2n_3').contextmenu(function(e){    
      $('#chain_2n_2').show()
      $('#chain_2n_3').hide()
      return false;
      });
      $('#chain_2n_3').click(function(e){    
      $('#chain_2n_3').hide()
      $('#chain_2n_4').show()
      });
      $('#chain_2n_4').contextmenu(function(e){    
      $('#chain_2n_3').show()
      $('#chain_2n_4').hide()
      return false;
      });
      </script>
    </div>

    <div class="step slide" data-x="5200" data-y="4700" data-rotate-x="-30" data-rotate-y="35" data-scale="1" data-z="-2000">
      <h3>Checklist</h3>

      <ul class="check">
        <li class="check">Range Loops</li>

        <li class="check"><code class="keyword">auto</code></li>

        <li class="check">Lambda Functions</li>

        <li class="check"><code>boost::iterator_facade</code></li>

        <li class="check"><code>boost::iterator_range</code></li>
      </ul>
    </div>

    <div id="outline-compo" class="step slide" data-x="0" data-y="0" data-z="300" data-rotate-x="90" data-scale="0.3">
      <h3>Outline</h3>

      <ul class="outline">
        <li class="other">Introduction</li>

        <li class="other">Core Language Improvements</li>

        <li class="other">Boost Helpers</li>

        <li class="current">Composition

          <ul>
            <li class="sub_other">The Problem</li>

            <li class="sub_other">RValue References</li>

            <li class="sub_other"><code class="keyword">decltype</code>s</li>
          </ul>
        </li>

        <li class="other">Variadics</li>

        <li class="other">Concluding Mini-Example</li>
      </ul>
    </div>

    <div class="step slide" data-x="0" data-y="0" data-z="500" data-rotate-x="90" data-rotate-y="30" data-scale="0.3">
      <h3>Composition</h3>

      <ol>
        <li>Much of Python itertool's power comes from composition

          <div class="smaller">
            <pre class='brush: python; gutter: false; toolbar: false'>
            for i, e in enumerate(chain(v1, v2, v3)):
                ...
</pre>
          </div>
        </li>

        <li class='substep'>Similarly, we should have

          <div class="smaller">
            <pre class='brush: cpp; gutter: false; toolbar: false'>
                for(auto e: enumerate(chain(v1, v2, v3)))
                    ...
</pre>
          </div>(or, using some syntactic sugar,

          <div class="smaller">
            <pre class='brush: cpp; gutter: false; toolbar: false'>
                for(auto e: chain(v1, v2, v3) | enumerate())
                    ...
</pre>
          </div>)
        </li>

        <li class="substep">But how to implement composition?</li>
      </ol>
    </div>

    <div id="outline-compo-prob" class="step slide" data-x="0" data-y="0" data-z="700" data-rotate-y="60" data-rotate-x="90" data-scale="0.3">
      <h3>Outline</h3>

      <ul class="outline">
        <li class="other">Introduction</li>

        <li class="other">Core Language Improvements</li>

        <li class="other">Boost Helpers</li>

        <li class="current">Composition

          <ul>
            <li class="sub_current">The Problem</li>

            <li class="sub_other">RValue References</li>

            <li class="sub_other"><code class="keyword">decltype</code>s</li>
          </ul>
        </li>

        <li class="other">Variadics</li>

        <li class="other">Concluding Mini-Example</li>
      </ul>
    </div>

    <div class="step slide" data-x="0" data-y="0" data-z="900" data-rotate-y="90" data-rotate-x="90" data-scale="0.3">
      <h3>Range-Function Signature</h3>

      <h4>First Attempt</h4>

      <div class="smaller">
        <pre class='brush: cpp; gutter: false; toolbar: false'>
template&lt;class Fn, class Range&gt;
boost::iterator_range&lt;
        filter_it&lt;Fn, typename Range::const_iterator&gt;&gt;
    filter(const Fn &amp;fn, const Range &amp;r);
</pre>
      </div>

      <div class="substep baddyshown smaller">
        <pre class='brush: cpp; gutter: false; toolbar: false'>
vector&lt;size_t&gt; v{1, 2, 3, 4, 5, 6};
for(auto &amp;e: filter(g, v))
    ++e;
</pre>
      </div>
    </div>

    <div class="step slide" data-x="0" data-y="0" data-z="1100" data-rotate-y="90" data-rotate-x="90" data-scale="0.3">
      <h4>Second Attempt</h4>

      <div class="smaller">
        <pre class='brush: cpp; gutter: false; toolbar: false'>
template&lt;class Fn, class Range&gt;
boost::iterator_range&lt;
        filter_it&lt;Fn, typename Range::const_iterator&gt;&gt;
    filter(const Fn &amp;fn, const Range &amp;r);

template&lt;class Fn, class Range&gt;
boost::iterator_range&lt;
        filter_it&lt;Fn, typename Range::iterator&gt;&gt;
    filter(const Fn &amp;fn, Range &amp;r);
</pre>
      </div>

      <div class="substep baddyshown smaller">
        <pre class='brush: cpp; gutter: false; toolbar: false'>
vector&lt;size_t&gt; v{1, 2, 3, 4, 5, 6};
for(auto &amp;e: v | filter(f) | filter(g))
    ++e;
</pre>
      </div>
    </div>

    <div class="step slide" data-x="0" data-y="0" data-z="1300" data-rotate-y="120" data-rotate-x="90" data-scale="0.3">
      <h3>What's Causing The Problem?</h3>

      <ol>
        <li>As glossed before,

          <div class="smaller">
            <pre class='brush: cpp; gutter: false; toolbar: false'>
v | f() | g() 
</pre>
          </div>just synthetic sugar for

          <div class="smaller">
            <pre class='brush: cpp; gutter: false; toolbar: false'>
g(f(v))        
</pre>
          </div>

          <div class="substep">
            Problem really with

            <div class="baddyshown smaller">
              <pre class='brush: cpp; gutter: false; toolbar: false'>
for(auto &amp;e: filter(g, filter(f, v)))
    ++e;
</pre>
            </div>
          </div>
        </li>
      </ol>
    </div>

    <div class="step slide" data-x="0" data-y="0" data-z="1500" data-rotate-y="120" data-rotate-x="90" data-scale="0.3">
      <ol start="2">
        <li class="substep">In <code>filter(g, filter(f, v))</code>, note <code>filter(g, ...)</code> operating on a temporary object</li>

        <li class="substep">In C++, a temporary object binds only to a const reference</li>

        <li class="substep">Bubkes

          <div class="baddyshown smaller">
            <pre class='brush: cpp; gutter: false; toolbar: false'>
template&lt;class Fn, class Range&gt;
boost::iterator_range&lt;
        filter_it&lt;Fn, typename Range::const_iterator&gt;&gt;
    filter(const Fn &amp;fn, const Range &amp;r);

template&lt;class Fn, class Range&gt;
boost::iterator_range&lt;
        filter_it&lt;Fn, typename Range::iterator&gt;&gt;
    filter(const Fn &amp;fn, Range &amp;r);
</pre>
          </div>
        </li>
      </ol>
    </div>

    <div id="outline-compo-rvlaues" class="step slide" data-x="0" data-y="0" data-z="1700" data-rotate-y="150" data-rotate-x="90" data-scale="0.3">
      <h3>Outline</h3>

      <ul class="outline">
        <li class="other">Introduction</li>

        <li class="other">Core Language Improvements</li>

        <li class="other">Boost Helpers</li>

        <li class="current">Composition

          <ul>
            <li class="sub_other">The Problem</li>

            <li class="sub_current">RValue References</li>

            <li class="sub_other"><code class="keyword">decltype</code>s</li>
          </ul>
        </li>

        <li class="other">Variadics</li>

        <li class="other">Concluding Mini-Example</li>
      </ul>
    </div>

    <div class="step slide" data-x="0" data-y="0" data-z="1900" data-rotate-y="180" data-rotate-x="90" data-scale="0.3">
      <h3>C++03 Copies &amp; Temporaries</h3>

      <ol>
        <li>Creation from model-object by copying (/ assignment). <object data="images/copy.svg" width="800" height="200" type="image/svg+xml">
          </object></li>

        <li class="substep">Temporaries performance issue

          <ul>
            <li>Function return values

              <div class="smaller">
                <pre class='brush: cpp; gutter: false; toolbar: false'>
string foo()
{
    string s;
    ...
    return s;
}
</pre>
              </div>
            </li>
          </ul>
        </li>
      </ol>
    </div>

    <div class="step slide" data-x="0" data-y="0" data-z="2100" data-rotate-y="180" data-rotate-x="90" data-scale="0.3">
      <ol>
        <li style="list-style:none">
          <ul>
            <li>Swapping objects

              <div class="smaller">
                <pre class='brush: cpp; gutter: false; toolbar: false'>
template&lt;typename T&gt;
void swap(T &amp;a, T &amp;b)
{
    T tmp = a;
    a = b;
    b = tmp;
}
</pre>
              </div><object data="images/copy_swap.svg" width="800" height="400" type="image/svg+xml">
                </object>
            </li>
          </ul>
        </li>
      </ol>
    </div>

    <div class="step slide" data-x="0" data-y="0" data-z="2300" data-rotate-y="180" data-rotate-x="90" data-scale="0.3">
      <ul>
        <li style="list-style:none">
          <ul>
            <li>Self-resizing vectors

              <div class="smaller">
                <pre class='brush: cpp; gutter: false; toolbar: false'>
vector&lt;string&gt; v{a, b, c, d};
v.push_back(e);
</pre>
              </div><object data="images/vector_copy.svg" width="800" height="400" type="image/svg+xml">
                </object>
            </li>
          </ul>
        </li>

        <li class="substep">Resource <b>stealing</b> would solve this</li>
      </ul>
    </div>

    <div class="step slide" data-x="0" data-y="0" data-z="2500" data-rotate-y="210" data-rotate-x="90" data-scale="0.3"><img src="images/wonka.jpg" width=
    "70%"></div>

    <div class="step slide" data-x="0" data-y="0" data-z="2800" data-rotate-y="230" data-rotate-x="90" data-scale="0.3">
      <h3>The Move Ctor &amp; Assignment Operator</h3>

      <div class="foo_move smaller" id="foo_move_0">
        <pre class='brush: cpp toolbar: false'>
struct foo
{
    foo(const foo &amp;other){/* copy stuff from other */}
    foo(foo &amp;&amp;other)
    {/* steal stuff from other; reset other for dtor. */}
    
    foo &amp;operator=(const foo &amp;other)
    {/* copy stuff from other */ return *this;}
    foo &amp;operator=(foo &amp;&amp;other)
    {/*  steal stuff from other; reset other for dtor. */ 
        return *this;}
};
</pre>
      </div>

      <div class="foo_move smaller" id="foo_move_1" style="display:none" data-tip="Copy ctor/assgn">
        <pre class='brush: cpp toolbar: false highlight: [3, 7, 8]'>
struct foo
{
    foo(const foo &amp;other){/* copy stuff from other */}
    foo(foo &amp;&amp;other)
    {/* steal stuff from other; reset other for dtor. */}
    
    foo &amp;operator=(const foo &amp;other)
    {/* copy stuff from other */ return *this;}
    foo &amp;operator=(foo &amp;&amp;other)
    {/*  steal stuff from other; reset other for dtor. */ 
        return *this;}
};
</pre>
      </div>

      <div class="foo_move smaller" id="foo_move_2" style="display:none" data-tip="Move ctor/assgn; &amp;&amp; rvalue reference">
        <pre class='brush: cpp toolbar: false highlight: [4, 5, 9, 10, 11]'>
struct foo
{
    foo(const foo &amp;other){/* copy stuff from other */}
    foo(foo &amp;&amp;other)
    {/* steal stuff from other; reset other for dtor. */}
    
    foo &amp;operator=(const foo &amp;other)
    {/* copy stuff from other */ return *this;}
    foo &amp;operator=(foo &amp;&amp;other)
    {/*  steal stuff from other; reset other for dtor. */ 
        return *this;}
};
</pre>
      </div><script type="text/javascript">
$('#foo_move_0').click(function(e){    
      $('#foo_move_0').hide()
      $('#foo_move_1').show()
      });
      $('#foo_move_1').contextmenu(function(e){    
      $('#foo_move_0').show()
      $('#foo_move_1').hide()
      return false;
      });
      $('#foo_move_2').click(function(e){    
      $('#foo_move_2').hide()
      $('#foo_move_3').show()
      });
      $('#foo_move_1').click(function(e){    
      $('#foo_move_1').hide()
      $('#foo_move_2').show()
      });
      $('#foo_move_2').contextmenu(function(e){    
      $('#foo_move_1').show()
      $('#foo_move_2').hide()
      return false;
      });
      $('#foo_move_2').click(function(e){    
      $('#foo_move_2').hide()
      $('#foo_move_3').show()
      });
      $('#foo_move_3').contextmenu(function(e){    
      $('#foo_move_2').show()
      $('#foo_move_3').hide()
      return false;
      });
      </script>
    </div>

    <div class="step slide" data-x="0" data-y="0" data-z="2950" data-rotate-y="230" data-rotate-x="90" data-scale="0.3">
      <object data="images/move.svg" width="800" height="200" type="image/svg+xml">
        </object>
    </div>

    <div class="step slide" data-x="200" data-y="200" data-z="3100" data-rotate-y="230" data-rotate-x="90" data-scale="0.3">
      <ol>
        <li>Optimized composition

          <div class="smaller">
            <pre class='brush: cpp toolbar: false gutter: false'>
struct foo
{
    foo(bar &amp;&amp;);
};

bar g();

foo a(g());
</pre>
          </div>
        </li>
      </ol>
    </div>

    <div class="step slide" data-x="0" data-y="0" data-z="3100" data-rotate-y="230" data-rotate-x="90" data-scale="0.3">
      <h3>How This Helps</h3>

      <ol start="2">
        <li>Swapping objects

          <div>
            <div style="float: left; width: 50%;">
              <div class="move_swap smaller" id="move_swap_0">
                <pre class='brush: cpp toolbar: false'>
template&lt;typename T&gt;
void swap(T &amp;a, T &amp;b)
{
    T tmp = std::move(a);
    a = std::move(b);
    b = std::move(tmp);
}
</pre>
              </div>

              <div class="move_swap smaller" id="move_swap_1" style="display:none" data-tip="std::move creates an rvalue reference">
                <pre class='brush: cpp toolbar: false highlight: [4]'>
template&lt;typename T&gt;
void swap(T &amp;a, T &amp;b)
{
    T tmp = std::move(a);
    a = std::move(b);
    b = std::move(tmp);
}
</pre>
              </div><script type="text/javascript">
$('#move_swap_0').click(function(e){    
              $('#move_swap_0').hide()
              $('#move_swap_1').show()
              });
              $('#move_swap_1').contextmenu(function(e){    
              $('#move_swap_0').show()
              $('#move_swap_1').hide()
              return false;
              });
              </script>
            </div>

            <div style="float: right; width: 50%;">
              <object data="images/move_swap.svg" width="800" height="400" type="image/svg+xml">
                </object>
            </div>
          </div>
        </li>
      </ol>
    </div>

    <div class="step slide" data-x="-300" data-y="-300" data-z="3100" data-rotate-y="230" data-rotate-x="90" data-scale="0.3">
      <ol start="3">
        <li>
          <div>
            Self-resizing vectors <object data="images/vector_move.svg" width="800" height="200" type="image/svg+xml">
              </object>
          </div>
        </li>
      </ol>
    </div>

    <div class="step slide" data-x="0" data-y="0" data-z="3300" data-rotate-y="260" data-rotate-x="90" data-scale="0.3">
      <h3><code>filter</code> &amp; <code>enumerate</code> Revisited</h3>

      <div style="float: left; width: 50%;">
        <div class="smaller">
          <pre class='brush: cpp; gutter: false; toolbar: false highlight: [3, 7]'>
template&lt;class Fn, class Range&gt;
boost::iterator_range&lt;... blah ... &gt;
filter(const Fn &amp;f, Range &amp;&amp;r);

template&lt;class Range&gt;
boost::iterator_range&lt;... blah ... &gt;
enumerate(Range &amp;&amp;r);
</pre>
        </div>
      </div>

      <div style="float: right; width: 50%;">
        <div class="substep smaller">
          <pre class='brush: cpp; gutter: false; toolbar: false'>
vector&lt;size_t&gt; v;
enumerate(filter(f, v)); 
</pre>
        </div>

        <div class="substep smaller">
          <pre class='brush: cpp; gutter: false; toolbar: false'>
v | filter(f) | enumerate();
</pre>
        </div>
      </div>
    </div>

    <div id="outline-compo-decltype" class="step slide" data-x="0" data-y="0" data-z="3600" data-rotate-y="290" data-rotate-x="90" data-scale="0.3">
      <h3>Outline</h3>

      <ul class="outline">
        <li class="other">Introduction</li>

        <li class="other">Core Language Improvements</li>

        <li class="other">Boost Helpers</li>

        <li class="current">Composition

          <ul>
            <li class="sub_other">The Problem</li>

            <li class="sub_other">RValue References</li>

            <li class="sub_current"><code class="keyword">decltype</code>s</li>
          </ul>
        </li>

        <li class="other">Variadics</li>

        <li class="other">Concluding Mini-Example</li>
      </ul>
    </div>

    <div class="step slide" data-x="0" data-y="0" data-z="3900" data-rotate-y="320" data-rotate-x="90" data-scale="0.3">
      <h3>Motivation</h3>

      <p>Should this code compile?</p>

      <div class="smaller">
        <pre class='brush: cpp; gutter: false; toolbar: false'>
for(auto &amp;e, filter(f, v))
    ++e;
</pre>
      </div>

      <div class="substep">
        <p>It depends whether <code>v</code> is <code>const</code></p>

        <div style="float: left; width: 50%;">
          <div class="smaller">
            <pre class='brush: cpp; gutter: false; toolbar: false'>
vector&lt;size_t&gt; v;
...
for(auto &amp;e, filter(f, v))
    ++e;
</pre>
          </div>
        </div>

        <div style="float: right; width: 50%;">
          <div class="baddyshown smaller">
            <pre class='brush: cpp; gutter: false; toolbar: false'>
const vector&lt;size_t&gt; v;
...
for(auto &amp;e, filter(f, v))
    ++e;
</pre>
          </div>
        </div>
      </div>
    </div>

    <div class="step slide" data-x="0" data-y="0" data-z="4100" data-rotate-y="320" data-rotate-x="90" data-scale="0.3">
      <div class="substep">
        Assuming we have something like:

        <div class="smaller">
          <pre class='brush: cpp; gutter: false; toolbar: false'>
template&lt;class Fn, class It&gt;
class filter_iterator;
</pre>
        </div>
      </div>

      <div class="substep">
        what we'd like is something like

        <div class="baddyshown smaller">
          <pre class='brush: cpp; toolbar: false highlight: [4, 5, 9, 10]'>
template&lt;class Fn, class Range&gt;
boost::iterator_range&lt;filter_iterator&lt;
    f, 
    r.begin() is typename Range::const_iterator? 
        Range::const_iterator: Range::iterator&gt;&gt;
filter(const Fn &amp;f, Range &amp;&amp;r)
{
    typedef
        r.begin() is typename Range::const_iterator? 
            Range::const_iterator: Range::iterator   
        orig_it_t;

    ...
}
</pre>
        </div>
      </div>
    </div>

    <div class="step slide" data-x="0" data-y="0" data-z="4350" data-rotate-y="350" data-rotate-x="90" data-scale="0.3">
      <h3><code class="keyword">decltype</code> - <code class="keyword">auto</code>'s Complementor</h3>

      <p><code class="keyword">decltype</code> evaluates an expression's declared type</p>

      <div class="smaller">
        <pre class='brush: cpp; gutter: false; toolbar: false'>
decltype(foo()) a = foo();
</pre>
      </div>

      <div class="smaller">
        <pre class='brush: cpp; gutter: false; toolbar: false'>
decltype(sqrt(-0.2)) a;
</pre>
      </div>

      <div class="substep">
        <p>Why not <code class="keyword">auto</code>?</p>

        <div class="substep smaller">
          <pre class='brush: cpp; gutter: false; toolbar: false'>
auto a = foo();
decltype(foo()) a;
</pre>
        </div>
      </div>
    </div>

    <div class="step slide" data-x="0" data-y="0" data-z="4550" data-rotate-y="380" data-rotate-x="90" data-scale="0.3">
      <h3><code>filter</code> Revisited</h3>

      <div class="baddyshown smaller">
        <pre class='brush: cpp; toolbar: false highlight: [4, 8]'>
template&lt;class Fn, class Range&gt;
boost::iterator_range&lt;filter_iterator&lt;
    f, 
    decltype(r.begin())&gt;&gt;
filter(const Fn &amp;f, Range &amp;&amp;r)
{
    typedef
        decltype(r.begin())
        orig_it_t;

    ...
}
</pre>
      </div>
    </div>

    <div class="step slide" data-x="0" data-y="0" data-z="4750" data-rotate-y="410" data-rotate-x="90" data-scale="0.3">
      <h3>New Return-Type Syntax</h3>

      <div class="smaller">
        <pre class='brush: cpp; toolbar: false highlight: [2, 5]'>
template&lt;class Fn, class Range&gt;
    auto filter(const Fn &amp;f, Range &amp;&amp;r) -&gt;
        boost::iterator_range&lt;filter_iterator&lt;
            f, 
            decltype(r.begin())&gt;&gt;
    {
        typedef
            decltype(r.begin())
            it_t;

        ...
    }
    </pre>
        </div>
        </div>

        <div class="step slide" data-x="0" data-y="0" data-z="4950" data-rotate-y="440" data-rotate-x="90" data-scale="0.3">
        <h3>Checklist</h3>

        <div>
            <div>
            <div style="float: left; width: 50%;">
                <ul class="check">
                <li class="check">Range Loops</li>

                <li class="check"><code class="keyword">auto</code></li>

                <li class="check">Lambda Functions</li>

                <li class="check"><code>boost::iterator_facade</code></li>

                <li class="check"><code>boost::iterator_range</code></li>
                </ul>
            </div>

            <div style="float: right; width: 40%;">
                <ul class="check">
                <li class="check"><code>&amp;&amp;</code></li>

                <li class="check"><code>std::move</code></li>

                <li class="check"><code class="keyword">decltype</code></li>

                <li class="check"><code class="keyword">auto</code> <code>... -&gt;</code></li>
                </ul>
            </div>
            </div>
        </div>
        </div>

        <div id="outline-variadics" class="step slide" data-x="4700" data-y="6600" data-rotate="180" data-scale="1">
        <h3>Outline</h3>

        <ul class="outline">
            <li class="other">Introduction</li>

            <li class="other">Core Language Improvements</li>

            <li class="other">Boost Helpers</li>

            <li class="other">Composition</li>

            <li class="current">Variadics

            <ul>
                <li class="sub_current">Motivation</li>

                <li class="sub_other">Tuples</li>

                <li class="sub_other">Tuple Metaprogramming</li>

                <li class="sub_other">Variadics Metaprogramming</li>
            </ul>
            </li>

            <li class="other">Concluding Mini-Example</li>
        </ul>
        </div>

        <div class="step slide" data-x="5800" data-y="6200" data-rotate="270" data-scale="0.3">
        <h3>Variadic Templates</h3>When you not only don't know the types, you don't their #.
        </div>

        <div class="step slide" data-x="5800" data-y="6600" data-rotate="270" data-scale="0.3"><img src="images/picard.jpg" width="80%"></div>

        <div class="step slide" data-x="5800" data-y="7200" data-rotate="270" data-scale="0.3">
        <h3>Motivation</h3>

        <div style="float: left; width: 50%;">
            <ol>
            <li>
                <div>
                What's the type?

                <div class="smaller">
                    <pre class='brush: cpp; toolbar: false gutter: false'>
    vector&lt;string&gt; assets{'asset0', 'asset1'};
    list&lt;size_t&gt; tzs{0, 1, 3};
    for(auto e: product(assets, tzs))
        ...
    </pre>
                </div>

                <div class="substep">
                    and now?

                    <div class="smaller">
                    <pre class='brush: cpp; toolbar: false gutter: false'>
    vector&lt;string&gt; assets{'asset0', 'asset1'};
    list&lt;size_t&gt; tzs{0, 1, 3};
    vector&lt;date&gt; dates{...}
    for(auto e: product(assets, tzs, dates))
        ...
    </pre>
                    </div>
                </div>
                </div>
            </li>
            </ol>
        </div>

        <div style="float: right; width: 50%;">
            <ol start="2">
            <li class="substep">What's the signature of chain?

                <div class="smaller">
                <pre class='brush: cpp; gutter: false; toolbar: false'>
    vector&lt;size_t&gt; v1{1, 2, 3}; 
    set&lt;size_t&gt; v2{4, 5, 6, 7};
    list&lt;size_t&gt; v3{6, 7, 8, 9};
    for(auto e: chain(v1, v2, v3))
        cout &lt;&lt; e &lt;&lt; endl;
    </pre>
                </div>
            </li>
            </ol>
        </div>
        </div>

        <div id="outline-variadics-tuples" class="step slide" data-x="5800" data-y="7800" data-rotate="270" data-scale="0.3">
        <h3>Outline</h3>

        <ul class="outline">
            <li class="other">Introduction</li>

            <li class="other">Core Language Improvements</li>

            <li class="other">Boost Helpers</li>

            <li class="other">Composition</li>

            <li class="current">Variadics

            <ul>
                <li class="sub_other">Motivation</li>

                <li class="sub_current">Tuples</li>

                <li class="sub_other">Tuple Metaprogramming</li>

                <li class="sub_other">Variadics Metaprogramming</li>
            </ul>
            </li>

            <li class="other">Concluding Mini-Example</li>
        </ul>
        </div>

        <div class="step slide" data-x="5800" data-y="8400" data-rotate="270" data-scale="0.3">
        <h3>Tuple</h3>

        <ol>
            <li>Sort of an extension of <code>pair</code></li>

            <li class="substep">Type

            <div class="smaller">
                <pre class='brush: cpp; gutter: false; toolbar: false'>
    tuple&lt;size_t, string, date&gt; t;
    </pre>
            </div>
            </li>

            <li class="substep">Creating:

            <div class="smaller">
                <pre class='brush: cpp;gutter: false; toolbar: false'>
    tuple&lt;size_t, string, date&gt; t = make_tuple(12, "asset0", date(12, 10, 2001));
    auto t = make_tuple(12, "asset0", date(12, 10, 2001));
    </pre>
            </div>
            </li>
        </ol>
        </div>

        <div class="step slide" data-x="6000" data-y="8400" data-rotate="270" data-scale="0.3">
        <ol start="4">
            <li>Size:

            <div class="smaller">
                <pre class='brush: cpp; gutter: false; toolbar: false'>
    tuple&lt;size_t, string, date&gt; t;
    cout &lt;&lt; tuple_size&lt;t&gt;::value;
    </pre>
            </div>a compile-time expression
            </li>

            <li class="substep">Element access:

            <div class="smaller">
                <pre class='brush: cpp;gutter: false; toolbar: false'>
    cout  &lt;&lt; get&lt;0&gt;(t)  &lt;&lt; " " &lt;&lt; get&lt;1&gt;(t);
    </pre>
            </div>another compile-time expression
            </li>
        </ol>
        </div>

        <div id="outline-variadics-meta-tuples" class="step slide" data-x="5800" data-y="9000" data-rotate="270" data-scale="0.3">
        <h3>Outline</h3>

        <ul class="outline">
            <li class="other">Introduction</li>

            <li class="other">Core Language Improvements</li>

            <li class="other">Boost Helpers</li>

            <li class="other">Composition</li>

            <li class="current">Variadics

            <ul>
                <li class="sub_other">Motivation</li>

                <li class="sub_other">Tuples</li>

                <li class="sub_current">Tuple Metaprogramming</li>

                <li class="sub_other">Variadics Metaprogramming</li>
            </ul>
            </li>

            <li class="other">Concluding Mini-Example</li>
        </ul>
        </div>

        <div class="step slide" data-x="5800" data-y="9600" data-rotate="270" data-scale="0.3">
        <h3>Example: Wrongly Adding A Tuple's Elements</h3>

        <ol>
            <li>Adding a length-4 tuple's elements

            <div class="smaller">
                <pre class='brush: cpp; gutter: false; toolbar: false'>
    typedef tuple&lt;double, double, double, double&gt; tup_4_t;
    double add_elems(const tup_4_t &amp;t)
    {
        return get&lt;0&gt;(t) + get&lt;1&gt;(t) + get&lt;2&gt;(t) + get&lt;3&gt;(t);
    }   
    </pre>
            </div>
            </li>

            <li class="substep">Generalizing:

            <div class="tup_add smaller" id="tup_add_0">
                <pre class='brush: cpp toolbar: false'>
    template&lt;class Tup&gt;
    double add_elems(const Tup &amp;t)
    {
        double sum = 0;
        for(auto i = 0; i &lt; tuple_size&lt;Tup&gt;::value; ++i)
            sum += get&lt;i&gt;(t);
        return sum;
    }   
    </pre>
            </div>

            <div class="baddyshown tup_add smaller" id="tup_add_1" style="display:none" data-tip="get&lt;i&gt; is compile-time i">
                <pre class='brush: cpp toolbar: false highlight: [6]'>
    template&lt;class Tup&gt;
    double add_elems(const Tup &amp;t)
    {
        double sum = 0;
        for(auto i = 0; i &lt; tuple_size&lt;Tup&gt;::value; ++i)
            sum += get&lt;i&gt;(t);
        return sum;
    }   
    </pre>
            </div><script type="text/javascript">
    $('#tup_add_0').click(function(e){    
                $('#tup_add_0').hide()
                $('#tup_add_1').show()
                });
                $('#tup_add_1').contextmenu(function(e){    
                $('#tup_add_0').show()
                $('#tup_add_1').hide()
                return false;
                });
            </script>
            </li>
        </ol>
        </div>

        <div class="step slide" data-x="5800" data-y="10200" data-rotate="270" data-scale="0.3"><img src="images/aragorn.jpg" width="80%"></div>

        <div class="step slide" data-x="5800" data-y="10800" data-rotate="270" data-scale="0.3">
        <h3>A Widely-Applicable Technique</h3>

        <div class="tup_add_almost smaller" id="tup_add_almost_0">
            <pre class='brush: cpp toolbar: false'>
    template&lt;class Tup, size_t N&gt;
    struct manip
    {
        inline static double add_elems(const Tup &amp;t)
        {
            return N == tuple_size&lt;Tup&gt;::value? 
                0: 
                get&lt;N&gt;(t) + manip&lt;N + 1&gt;(t)::add_elems(t);
        }   
    };
    </pre>
        </div>

        <div class="baddyshown tup_add_almost smaller" id="tup_add_almost_1" style="display:none" data-tip="Compiler sez bitch please">
            <pre class='brush: cpp toolbar: false highlight: [8]'>
    template&lt;class Tup, size_t N&gt;
    struct manip
    {
        inline static double add_elems(const Tup &amp;t)
        {
            return N == tuple_size&lt;Tup&gt;::value? 
                0: 
                get&lt;N&gt;(t) + manip&lt;N + 1&gt;(t)::add_elems(t);
        }   
    };
    </pre>
        </div><script type="text/javascript">
    $('#tup_add_almost_0').click(function(e){    
                $('#tup_add_almost_0').hide()
                $('#tup_add_almost_1').show()
                });
                $('#tup_add_almost_1').contextmenu(function(e){    
                $('#tup_add_almost_0').show()
                $('#tup_add_almost_1').hide()
                return false;
                });
        </script>

        <div class="substep smaller">
            <pre class='brush: cpp; gutter: false; toolbar: false'>
    template&lt;class Tup&gt;
    inline double add_elems(const Tup &amp;t)
    {
        return manip&lt;Tup, 0&gt;::add_elems(t);
    }
    </pre>
        </div>
        </div>

        <div class="step slide" data-x="6100" data-y="10800" data-rotate="270" data-scale="0.3">
        <div class="smaller">
            <pre class='brush: cpp toolbar: false highlight: [1, 6]'>
    template&lt;class Tup, size_t N, size_t L&gt;
    struct manip
    {
        inline static double add_elems(const Tup &amp;t)
        {
            return get&lt;N&gt;(t) + manip&lt;N + 1, L&gt;(t)::add_elems(t);
        }   
    };
    </pre>
        </div>

        <div class="substep smaller">
            <pre class='brush: cpp toolbar: false highlight: [1, 2, 6]'>
    template&lt;class Tup, size_t N&gt;
    struct manip&lt;Tup, N, N&gt;
    {
        inline static double add_elems(const Tup &amp;)
        {
            return 0;
        }   
    };
    </pre>
        </div>

        <div class="substep smaller">
            <pre class='brush: cpp toolbar: false highlight: [4]'>
    template&lt;class Tup&gt;
    inline double add_elems(const Tup &amp;t)
    {
        return manip&lt;Tup, 0, tuple_size&lt;Tup&gt;::value&gt;::add_elems(t);
    }
    </pre>
        </div>
        </div>

        <div class="step slide" data-x="6500" data-y="10800" data-rotate="270" data-scale="0.3"><img src="images/tup_add.svg"></div>

        <div class="step slide" data-x="5800" data-y="11200" data-rotate="270" data-scale="0.3"><img src="images/impossibru.jpg" width="80%"></div>

        <div id="outline-variadics-meta-variadics" class="step slide" data-x="5800" data-y="11800" data-rotate="270" data-scale="0.3">
        <h3>Outline</h3>

        <ul class="outline">
            <li class="other">Introduction</li>

            <li class="other">Core Language Improvements</li>

            <li class="other">Boost Helpers</li>

            <li class="other">Composition</li>

            <li class="current">Variadics

            <ul>
                <li class="sub_other">Motivation</li>

                <li class="sub_other">Tuples</li>

                <li class="sub_other">Tuple Metaprogramming</li>

                <li class="sub_current">Variadics Metaprogramming</li>
            </ul>
            </li>

            <li class="other">Concluding Mini-Example</li>
        </ul>
        </div>

        <div class="step slide" data-x="5800" data-y="12400" data-rotate="270" data-scale="0.3">
        <h3>Declaring Unknown # Of Unknown Types</h3>

        <div style="float: left; width: 50%;">
            <ol>
            <li>
                <code>chain</code> declaration

                <div class="smaller">
                <pre class='brush: cpp toolbar: false highlight: [1, 2]'>
    template&lt;class... Range&gt;
    auto chain(Ranges... ranges) -&gt;
        blah blah
    {
        blah blah
    };
    </pre>
                </div>
            </li>

            <li class="substep"><code>...</code> on the left means unspecified # types</li>
            </ol>
        </div>

        <div style="float: right; width: 50%;">
            <ul>
            <li class="substep">
                <div class="smaller">
                <pre class='brush: cpp toolbar: false; gutter:false;'>
    vector&lt;size_t&gt; v1; list&lt;size_t&gt; v2;
    chain(v1, v2)
    </pre>
                </div>

                <p>binds</p>

                <div class="smaller">
                <pre class='brush: cpp toolbar: false; gutter:false;'>
    ...Ranges &#8592; vector&lt;size_t&gt;, list&lt;size_t&gt;
    ...ranges &#8592; v1, v2
    </pre>
                </div>
            </li>

            <li class="substep">
                <div class="smaller">
                <pre class='brush: cpp toolbar: false; gutter:false;'>
    vector&lt;size_t&gt; v1; list&lt;size_t&gt; v2;
    chain(v1, v2, v1)
    </pre>
                </div>

                <p>binds</p>

                <div class="smaller">
                <pre class='brush: cpp toolbar: false; gutter:false;'>
    ...Ranges &#8592; vector&lt;size_t&gt;, list&lt;size_t&gt;, vector&lt;size_t&gt;
    ...ranges &#8592; v1, v2, v1
    </pre>
                </div>
            </li>
            </ul>
        </div>
        </div>

        <div class="step slide" data-x="6050" data-y="12400" data-rotate="270" data-scale="0.3">
        <ol start="3">
            <li>Orthonoal to constness/reference, so, better:

            <div class="smaller">
                <pre class='brush: cpp toolbar: false highlight: [2]'>
    template&lt;class... Range&gt;
    auto chain(Ranges&amp;&amp;... ranges) -&gt;
        blah blah
    {
        blah blah
    };
    </pre>
            </div>
            </li>

            <li class="substep">Combining with regular templates possible; must appear last

            <div class="smaller">
                <pre class='brush: cpp toolbar: false highlight: [2]'>
    template&lt;class Fn, class... Range&gt;
    auto filter(const Fn &amp;fn, Ranges&amp;&amp;... ranges) -&gt;
        blah blah
    {
        blah blah
    };
    </pre>
            </div>
            </li>
        </ol>
        </div>

        <div class="step slide" data-x="5800" data-y="13000" data-rotate="270" data-scale="0.3">
        <h3>Type Unpacking</h3>

        <p><code>some-type ...</code> (on the right!) is type unpacking</p>

        <div>
            <div style="float: left; width: 50%;">
            <ol>
                <li class="substep">
                <div class="smaller">
                    <pre class='brush: cpp toolbar: false highlight: [5, 6]'>
    template&lt;typename... Its&gt;
    auto foo(Its&amp;&amp;... its) -&gt;
        blah blah
    {
        Its...
        // Its0, Its1, Its2 etc.
    };
    </pre>
                </div>
                </li>
            </ol>
            </div>

            <div style="float: right; width: 50%;">
            <ol start="2">
                <li class="substep">
                <div class="smaller">
                    <pre class='brush: cpp toolbar: false highlight: [5, 6, 7, 8]'>
    template&lt;class... Ranges&gt;
    auto foo(Ranges&amp;&amp;... ranges) -&gt;
        blah blah
    {
        std::iterator_traits&lt;Ranges&gt;::iterator...
        /* std::iterator_traits&lt;Ranges0&gt;::iterator,
        *   std::iterator_traits&lt;Ranges1&gt;::iterator,
        *   etc. */
    };
    </pre>
                </div>
                </li>
            </ol>
            </div>
        </div>
        </div>

        <div class="step slide" data-x="6000" data-y="13000" data-rotate="270" data-scale="0.3">
        <ol start="3">
            <li>This is illegal

            <div class="baddyshown smaller">
                <pre class='brush: cpp toolbar: false highlight: [5, 6]'>
    template&lt;typename... Its&gt;
    auto foo(Its&amp;&amp;... its) -&gt;
        blah blah
    {
        typedef Its... my_its_t;
        // typedef Its0, Its1, Its2 etc my_its_t;
    };
    </pre>
            </div>
            </li>
        </ol>
        </div>

        <div class="step slide" data-x="5800" data-y="13600" data-rotate="270" data-scale="0.3">
        <h3>Expression Unpacking</h3>

        <p><code>some-expression ...</code> (on the right!) is expression unpacking</p>

        <div>
            <div style="float: left; width: 50%;">
            <ol>
                <li class="substep">
                <div class="smaller">
                    <pre class='brush: cpp toolbar: false highlight: [5, 6]'>
    template&lt;typename... Its&gt;
    auto foo(Its&amp;&amp;... its) -&gt;
        blah blah
    {
        *its...
        // *its0, *its1, etc.
    };
    </pre>
                </div>
                </li>
            </ol>
            </div>

            <div style="float: right; width: 50%;">
            <ol start="2">
                <li class="substep">
                <div class="smaller">
                    <pre class='brush: cpp toolbar: false highlight: [5, 6, 7, 8]'>
    template&lt;class... Ranges&gt;
    auto foo(Ranges&amp;&amp;... ranges) -&gt;
        blah blah
    {
        std::begin(ranges)...;
        /* std::begin(ranges0),
        *   std::begin(ranges1),
        *   etc. */
    };
    </pre>
                </div>
                </li>
            </ol>
            </div>
        </div>
        </div>

        <div class="step slide" data-x="6000" data-y="13600" data-rotate="270" data-scale="0.3">
        <ol start="3">
            <li>Is this legal?

            <div class="smaller">
                <pre class='brush: cpp toolbar: false highlight: [5]'>
    template&lt;typename... Its&gt;
    auto foo(Its&amp;&amp;... its) -&gt;
        blah blah
    {
        f(*its);
    };
    </pre>
            </div>
            </li>
        </ol>
        </div>

        <div class="step slide" data-x="5800" data-y="14200" data-rotate="270" data-scale="0.3">
        <div>
            So what can be done with them?
        </div>

        <div class="substep">
            For one: use with tuples, manipulate with "recursive" technique seen before
        </div>
        </div>

        <div id="outline-concluding_mini" class="step slide" data-x="2600" data-y="2800" data-rotate="127" data-scale="2">
        <h3>Outline</h3>

        <ul class="outline">
            <li class="other">Introduction</li>

            <li class="other">Core Language Improvements</li>

            <li class="other">Boost Helpers</li>

            <li class="other">Composition</li>

            <li class="other">Variadics</li>

            <li class="current">Concluding Mini-Example</li>
        </ul>
        </div>

        <div class="step slide" data-x="-5600" data-y="3200" data-rotate="127" data-scale="5">
        <h3><code>chain_it</code> class</h3>

      <div class="smaller">
        <pre class='brush: cpp toolbar: false'>
template&lt;class It_Tuple&gt;
struct chain_it :
    public boost::iterator_facade&lt;
        blah blah
{
    It_Tuple m_b, m_e;

    explicit chain_it(const It_Tuple &amp;b, const It_Tuple &amp;e) :
        m_b(b), m_e(e) {}

    void increment()
    {
        enum{n = std::tuple_size&lt;It_Tuple&gt;&gt;::value};
        manip&lt;It_Tuple, 0, n&gt;::inc(m_b, m_e);
    }

    ...
};
</pre>
      </div>
    </div>

    <div class="step slide" data-x="-11700" data-y="4000" data-rotate="127" data-scale="5">
      <h3><code>manip</code> classes</h3>

      <div class="smaller">
        <pre class='brush: cpp toolbar: false'>
template&lt;class It_Tuple, std::size_t L&gt;
struct manip&lt;It_Tuple, L, L&gt;
{
    static void inc(It_Tuple &amp;, const It_Tuple &amp;)
    {
        // Do nothing.
    }
};
</pre>
      </div>
    </div>

    <div class="step slide" data-x="-17000" data-y="8000" data-rotate="127" data-scale="5">
      <h3><code>manip</code> classes</h3>

      <div class="smaller">
        <pre class='brush: cpp toolbar: false'>
template&lt;class It_Tuple, std::size_t N, std::size_t L&gt;
struct manip
{
    static void inc(It_Tuple &amp;c, const It_Tuple &amp;e)
    {
        if(std::get&lt;N&gt;(c) == std::get&lt;N&gt;(e))
        {
            manip&lt;It_Tuple, N + 1, L&gt;::inc(c, e);
            return;
        }

        ++std::get&lt;N&gt;(c);
    }
};
</pre>
      </div>
    </div>

    <div class="step slide" data-x="-17000" data-y="15000" data-rotate="127" data-scale="5">
      <h3><code>filter</code> Function</h3>

      <div class="smaller">
        <pre class='brush: cpp toolbar: false'>
template&lt;class... Ranges&gt;
auto chain(Ranges&amp;&amp;... ranges) -&gt; 
    boost::iterator_range&lt;
        detail::chain_it&lt;
            decltype(std::make_tuple(std::begin(ranges)...))&gt;&gt;
{
    typedef
        detail::chain_it&lt;decltype(std::make_tuple(std::begin(ranges)...))&gt;
        it_t;

    auto b = std::make_tuple(std::begin(ranges)...);
    auto e = std::make_tuple(std::end(ranges)...);

    return boost::make_iterator_range(it_t(b, e), it_t(e, e));
}
</pre>
      </div>
    </div><script src="js/shCore.js" type="text/javascript">
</script><script src="js/shBrushCpp.js" type="text/javascript">
</script><script src="js/shBrushPython.js" type="text/javascript">
</script><script type="text/javascript">
SyntaxHighlighter.all()
    </script><script src="js/impress.js" type="text/javascript">
</script><script type="text/javascript">
impress().init();
    </script>
  </div>
</body>
</html>
